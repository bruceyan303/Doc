//*******************************************免责声明*******************************************//
/*无锡矽杰微电子有限公司（简称：无锡矽杰微）保留关于该历程可靠性、功能和设计方面的改进作进一步说明
的权利。由于使用本历程中的信息或内容而导致的直接，间接，特别附带结果的损害，无锡矽杰微没有义务负责
本历程中代码的应用仅仅是用来做功能演示，本公司不保证这些代码没有更深入的测试就能适用。本历程中使用
的软件，都是依据授权或保密合约所合法提供的，并且只能在这些合约的许可条件下使用或者复制。无锡矽杰微
的产品不是专门设计来应用于生命维持的用具，装置或者系统。无锡矽杰微的产品不支持而且禁止在这些方面的
应用。本历程内容如有变动恕不另作通知，具体更新信息，请参考公司官方网站www.xjmcu.com。*/
//===================================//
//主频：8M/4T
//功能介绍：
//TCC控制P64口输出200ms波形
//===================================//
//==============================================================//
//头文件	运用头文件	IOC页寄存器定义文件
//==============================================================//
#include "XC8P9520.h"
#define EI()  __asm__(" ei ")
#define DI()  __asm__(" di ")
#define NOP() __asm__(" nop ")
#define CONTW(VAL)			__asm__("mov a,@"#VAL"\n ctw")			//CTW = VAL：CONT寄存器赋值
#define IOCP_W(REG,VAL)		__asm__("mov a,@"#VAL"\n iw "#REG)		//REG = VAL：IOC页寄存器赋值
#define IOCP_R(RAM,REG)		__asm__("ir "#REG"\n mov "#RAM",a")		//RAM = REG：IOC页寄存器读值
//=================================================================//
//								中断保护定义		    			 //
//=================================================================//
#define PUSH(A_REG,R3_REG)	__asm__("mov "#A_REG",a\n swap "#A_REG"\n swapa STATUS\n mov "#R3_REG",a")	//中断入栈保护	
#define POP(A_REG,R3_REG)	__asm__("swapa "#R3_REG"\n mov STATUS,a\n swapa "#A_REG)					//中断出栈保护恢复
volatile __at(0x10) unsigned char A_BUFF;		//中断ACC保护RAM
volatile __at(0x11) unsigned char R3_BUFF;		//中断STATUS保护RAM

void CLR_RAM();
void IO_Init(void);
void TCC_Init(void);
char	i,j;	//中间数
char	X1,X2;	//乘数X1,X2
int		sum;	//积

int		C1,C2;	//被除数C1，除数C2
char	yu,shan;
//根据需要修改数据类型

//===================================//
//初始化RAM:10H~3FH
//===================================//
void CLR_RAM()
{
	for(RSR=0x90;RSR<0xFF;RSR++)	//清零 BANK0 RAM
	{IAR = 0;}
	IAR	= 0;
}


//===================================//
//MAIN主程序
//===================================//
void main()
{
	CLR_RAM();

//乘法：例如12*18
	X2=18;
	sum=0;
	for(X1=12;i<X2;i++)
	{
	sum+=X1;
	}
	NOP();

//除法：例如158/6
	C1=158;
	C2=6;
	j=1;
	while(j>0)
	{
	C1=C1-C2;
	shan++;
		if(C1<C2)
		{
			j=0;
			yu=C1;
		}
	};
	NOP();



	while(1)
	{
		
	}
}

//===================================//
//中断服务程序
//===================================//
void int_isr(void) __interrupt 
{    	
	__asm__("org 0x08");
	PUSH(_A_BUFF,_R3_BUFF);			//中断入栈保护
	//===============中断程序===============//
	//===============中断程序===============//
	POP(_A_BUFF,_R3_BUFF);			//中断出栈保护恢复
}
