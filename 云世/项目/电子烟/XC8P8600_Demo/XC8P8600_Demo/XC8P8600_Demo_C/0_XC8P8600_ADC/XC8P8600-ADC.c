//*******************************************免责声明*******************************************//
/*无锡矽杰微电子有限公司（简称：无锡矽杰微）保留关于该例程可靠性、功能和设计方面的改进作进一步说明的权利。
由于使用本例程中的信息或内容而导致的直接，间接，特别附带结果的损害，无锡矽杰微没有义务负责。
本例程中代码的应用仅仅是用来做功能演示，本公司不保证这些代码没有更深入的测试就能适用。
本例程中使用的软件，都是依据授权或保密合约所合法提供的，并且只能在这些合约的许可条件下使用或者复制。
无锡矽杰微的产品不是专门设计来应用于生命维持的用具，装置或者系统。无锡矽杰微的产品不支持而且禁止在这些方面的应用。
本例程内容如有变动恕不另作通知，具体更新信息，请参考公司官方网站www.xjmcu.com。*/
//===================================================================================//
//主频：8M/4T  
//AD检测-DEMO功能说明： 
//P65 AD检测口
//检测电压小于0.5V： P63=0;P62=0;P61=0;P60=0;
//检测电压0.5V~1.0V：P63=0;P62=0;P61=0;P60=1;
//检测电压1.0V~2.0V：P63=0;P62=0;P61=1;P60=1;
//检测电压2.0V~3.0V：P63=0;P62=1;P61=1;P60=1;
//检测电压大于3.0V： P63=1;P62=1;P61=1;P60=1;
//=====================================================*/
//===================================================================================//
//==============================================================================//
//头文件	运用头文件	通用寄存器定义文件
//==============================================================================//
#include "XC8P8600.h"
#include "XJ_8600Define.h"
//===================================//
//void file_clrRam(void);
//void file_init(void);
//void file_project_init(void);
//===================================//
//中断服务程序
//===================================//
void int_isr(void) __interrupt 
{    	
	__asm__("org 0x08");			//中断入口地址			
	PUSH(_A_BUFF,_R3_BUFF);			//中断入栈保护
//=========Tcc中断程序===============//
	if(TCIF)					//判断TCIF是否为1
	{
		TCC	  += data_tcc;			//1/2 * 8 * (256-6) = 1000us	公式：1/IRC频率 * 预分频 * （256-初值）
		ISR    = 0xfe;				//清TC0中断标志位
		io_ledOut = !io_ledOut;			//P61口翻转

		reg_contTime++;
		if((reg_contTime % 10) == 0)//每10ms,reg_contTime个位数为0成立			
		{
			bit_end10ms = 1;			
			//PORT6_4 = !PORT6_4;	
		}
		if(reg_contTime >= 500)		//每0.5s
		{
			reg_contTime = 0;
			bit_end500ms = 1;
			//PORT6_4 = !PORT6_4;	
		}
	}
	if(ADIF)					//AD采样中断
	{	 
		ISR    = 0x0f;	
	//	file_adc_read();			//读取AD值
		PORT6_4 = !PORT6_4;	
	}
//===============中断程序===============//
	POP(_A_BUFF,_R3_BUFF);			//中断出栈保护恢复
}


//===================================//
//ADC初始化
//===================================//
/*void file_adc_set(void)
{		
	IOCP_W(ADPS,0x80);		//AD3设置为模拟输入口
	IOCP_W(ADCVS,0x19);		//ADC时钟：Fosc/16; ADC通道：AD3(P65); 内部基准电压：4V
	ADCON = 0x40;			//ADC使能
}*/
//===================================//
//AD采集值获取
//===================================//
void file_adc_read(void)
{
	IOCP_R(_ADATH_TEMP,ADATH);								//取AD转换值高8位
	IOCP_R(_ADATL_TEMP,ADATL);								//取AD转换值低8位
	ADCDATA_TEMP = ((ADATH_TEMP & 0xf0) << 4) + ADATL_TEMP;	//存放AD采集结果	
	ADCDATA_SUM += ADCDATA_TEMP;							//累加8次求平均
	ADCDATA_COUNT ++;
	if(ADCDATA_COUNT >= 8)
	{
		ADCDATA_COUNT = 0;		
		ADCDATA = ADCDATA_SUM / 8;
		ADCDATA_SUM = 0;
	}
}
//===================================//
//AD采集
//===================================//
void file_adc_start(void)
{
//-----查询方式采样AD值----------
	ADRUN = 1;												//使能AD转换
	while(ADRUN);											//等待转换完成
	file_adc_read();
//------AD采样结束进中断设置-------------
/*	 IOCP_W(IMR,0x11);		//开启AD中断使能控制
	 ADPD=1;				//使能ADC
	 ADRUN=1;				//开始AD转换*/
}
//===================================//
//初始化RAM:10H~3FH
//===================================//
void file_clrRam()
{
	for(RSR=0x90;RSR<0xCF;RSR++)	//清零 BANK0 RAM  IAR-R0,RSR-R4
	{IAR = 0;}
	 IAR = 0;
}
//===================================//
//端口初始化
//===================================//
void file_init(void)
{	
	CONTW(0x02);			//TCC 8分频
	TCC = data_tcc;			//1/2 * 8 * (256-6) = 1000us	公式：1/IRC频率 * 预分频 * （256-初值）
	PORT6 = 0;				//P6口输出低
	IOCP_W(P6CR,0x20);		//P65输入，其他口设为输出
	IOCP_W(PHDCR,0xff);		//端口上下拉控制寄存器，bit7-bit4对应P67-P64下拉;bit3-bit0对应P53-P50上拉 
	IOCP_W(PDCR,0xff);		//端口下拉控制寄存器，  bit6-bit4对应P62-P60,bit3-bit0对应P53-P50
	IOCP_W(PHCR,0xff);		//P6端口上拉控制寄存器  bit7-bit0对应P67-P60
	IOCP_W(WDTCR,0x00);		//WDT 使能控制寄存器
	IOCP_W(IMR,0x01);		//中断使能控制寄存器 
	ISR = 0x0;				//清TC0中断标志位 
}
//===================================//
//TC0初始化
//===================================//
void file_project_init(void)
{
	//file_adc_set();		//ADC初始化
	IOCP_W(ADPS,0x80);		//AD3设置为模拟输入口
	IOCP_W(ADCVS,0x19);		//ADC时钟：Fosc/16; ADC通道：AD3(P65); 内部基准电压：4V
	ADCON = 0x40;			//ADC使能
}

//===================================//
//MAIN主程序
//===================================//
void main()
{
	file_clrRam();					//清RAM
	file_init();					//io寄存器初始化
	file_project_init();			//程序所需功能设置
	EI();							//打开总中断
	while(1)
	{	 
		if(bit_end10ms)
		{
			bit_end10ms = 0;
			file_adc_start();		//每10ms，采集一次AD
		}
		/*if(bit_end500ms == 1)
		{
			bit_end500ms = 0;		//每0.5s，输出一次AD采集结果
			if(ADCDATA < 0x200)		//AD采样值小于0.5V-十进制512
			{
				PORT6_3 = 0;
				PORT6_2 = 0;
				PORT6_1 = 0;
				PORT6_0 = 0;
			}
			else if(ADCDATA < 0x400)//AD采样值小于1.0V-十进制1024
			{
				PORT6_3 = 0;
				PORT6_2 = 0;
				PORT6_1 = 0;
				PORT6_0 = 1;
			}	
			else if(ADCDATA < 0x800)//AD采样值小于2.0V-十进制2048
			{
				PORT6_3 = 0;
				PORT6_2 = 0;
				PORT6_1 = 1;
				PORT6_0 = 1;
			}
			else if(ADCDATA < 0xc00)//AD采样值小于3.0V
			{
				PORT6_3 = 0;
				PORT6_2 = 1;
				PORT6_1 = 1;
				PORT6_0 = 1;
			}
			else					//AD采样值大于3.0V
			{
				PORT6_3 = 1;
				PORT6_2 = 1;
				PORT6_1 = 1;
				PORT6_0 = 1;
			}									
		}*/
	}
}
